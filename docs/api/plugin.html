<!DOCTYPE html>
<html>
<head>
  <title>Kontra.js â€“ Kontra.plugin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/webcomponentsjs/0.7.22/webcomponents-lite.min.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/themes/prism.min.css">
  <link rel="stylesheet" href="../styles.css">

  <link rel="import" href="../components/main-nav.html">
  <link rel="import" href="../components/code-output.html">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-javascript.min.js"></script>
  <script src="../js/kontra.js"></script>
</head>
<body>
  <div class="content">
    <main-nav></main-nav>

    <main id="main">
      <div>
        <h1>Kontra.plugin</h1>

        <p>A minimal plugin architecture to enable sharing of common functionality. The plugin system is designed after the Interceptor Pattern and allows you to write functions that can be run before and after any Kontra object function.</p>

        <p>The plugin architecture also allows you to safely extend Kontra objects. This allows you to safely add additional properties without overriding ones that may already exist.</p>

        <pre><code class="language-javascript">let myPlugin = {
  beforeAdd(vector, vecToAdd) {
    console.log(`adding {${vecToAdd.x}, ${vecToAdd.y}} vector to {${vector.x}, ${vector.y}}`);
  },
  afterAdd(vector, result, vecToAdd) {
    console.log(`result of add was: {${result.x}, ${result.y}}`);
  }
};

kontra.plugin.register('vector', myPlugin);</code></pre>





        <section class="toc">
          <h2 id="toc"><a href="#toc" class="section-link">Table of Contents<span aria-hidden="true">#</span></a></h2>

          <ul aria-labeledby="toc">
            <li>
              <ul>
                <li><a href="#best-practices">Plugin Best Practices</a></li></li>
              </ul>
            </li>

            <li>
              <h3 id="methods">Methods</h3>
              <ul aria-labeledby="methods">
                <li><a href="#extend">kontra.plugin&#8203;.extend(object, properties)</a></li>
                <li><a href="#register">kontra.plugin&#8203;.register(object, plugin)</a></li>
                <li><a href="#unregister">kontra.plugin&#8203;.unregister(object, plugin)</a></li>
              </ul>
            </li>
          </ul>
        </section>





        <section>
          <h2 id="best-practices"><a href="#best-practices" class="section-link">Plugin Best Practices<span aria-hidden="true">#</span></a></h2>

          <ul>
            <li>Export your plugin object for the consumer to use.</li>
            <li>You should not register the plugin yourself. Instead, you should expect the consumer of your plugin to register it. This way the consumer can determine the order in which plugins should run.</li>
            <li>In your plugin docs, remind the user to register the plugin themselves.</li>
            <li>Gracefully handle errors in in your plugin code. As an idea, you could return <code>null</code> on an error so your plugin does not break the rest of the plugin chain.</li>
          </ul>

          <pre><code class="language-javascript">(function() {
  let myPlugin = {
    beforeAdd() {
      // ...
    },
    afterAdd() {
      // ...
    }
  }

  window.myPlugin = myPlugin;
  // or
  module.export = myPlugin;
  // or
  export default myPlugin;
})();</code></pre>

        </section>





        <section>
          <h2 id="extend"><a href="#extend" class="section-link">kontra.plugin&#8203;.extend(object, properties)<span aria-hidden="true">#</span></a></h2>

          <dl>
            <dt><strong>object</strong> <em>{string}</em></dt>
            <dd>Kontra object to add extend.</dd>
            <dt><strong>properties</strong> <em>{object}</em></dt>
            <dd>Properties to add to the Kontra object.</dd>
          </dl>

          <p>Safely extend a Kontra object with the provided properties. If the property already exists on the object, your property will not be added.</p>

          <pre><code class="language-javascript">kontra.plugin.extend('vector', {
  subtract: function(vec) {
    return kontra.vector(this.x - vec.x, this.y - vec.y);
  }
};  // all kontra.vectors will now have a subtract function</code></pre>

        </section>





        <section>
          <h2 id="register"><a href="#register" class="section-link">kontra.plugin&#8203;.register(object, plugin)<span aria-hidden="true">#</span></a></h2>

          <dl>
            <dt><strong>object</strong> <em>{string}</em></dt>
            <dd>Kontra object to attach plugin to.</dd>
            <dt><strong>plugin</strong> <em>{object}</em></dt>
            <dd>Plugin object with before and after functions.</dd>
          </dl>

          <p>Register a plugin to run before and/or after any function defined on the Kontra object.</p>

          <pre><code class="language-javascript">// Intercept kontra.vector.add function and run functions before and after it
let myPlugin = {
  beforeAdd(vector, vecToAdd) {
    console.log(`adding {${vecToAdd.x}, ${vecToAdd.y}} vector to {${vector.x}, ${vector.y}}`);
  },
  afterAdd(vector, result, vecToAdd) {
    console.log(`result of add was: {${result.x}, ${result.y}}`);
  }
};

kontra.plugin.register('vector', myPlugin);</code></pre>

          <h3>Before functions</h3>

          <p>Before functions run before the intercepted Kontra object function. They are defined by prefixing the function with <code>before</code> and the name of the intercepted function. The parameters passed to the function will be the context the function was called with followed by all parameters passed to the intercepted function.</p>

          <p>Before functions can modify the arguments passed to the intercepted function. To do this, you'll need to return an array that represents the new arguments. You can modify or pass through any argument in this way. If your function does not modify the arguments, you can return <code>null</code>.</p>

          <p>If multiple before functions are registered for the same intercepted function, they will be run in the order they were registered and will be passed the arguments from the previous before function.</p>

          <pre><code class="language-javascript">let logPlugin = {
  // `vector` is the vector the `add` function was called on
  // `vecToAdd` is the vector being passed to the `add` function
  beforeAdd(vector, vecToAdd) {
    console.log(`adding {${vecToAdd.x}, ${vecToAdd.y}} vector to {${vector.x}, ${vector.y}}`);

    // don't modify the arguments so return nothing
  }
}

let modifyArgsPlugin = {
  beforeAdd(vector, vecToAdd) {
    // modify the parameter being passed to the `add` function
    let newVector = kontra.vector(10, 20);
    return [newVector]
  }
}

let passThroughArgsPlugin = {
  beforeAdd(vector, vecToAdd) {
    // pass through the original argument to the `add` function but also
    // pass an additional one
    let newVector = kontra.vector(10, 20);
    return [vecToAdd, newVector]
  }
}</code></pre>

          <h3>After functions</h3>

          <p>After functions run after the intercepted Kontra object function. They are defined by prefixing the function with <code>after</code> and the name of the intercepted function. The parameters passed to the function will be the context the function was called with, the result of the intercepted function, followed by all parameters passed to the intercepted function.</p>

          <p>After functions can modify the result of the intercepted function. To do this, you return a new value as the result. If your function does not modify the result, you can return <code>null</code>.</p>

          <p>If multiple after functions are registered for the same intercepted function, they will be run in the order they were registered and will be passed the result from the previous after function.</p>

          <pre><code class="language-javascript">let logPlugin = {
  // `vector` is the vector the `add` function was called on
  // `result` is the result of the `add` function
  // `vecToAdd` is the vector being passed to the `add` function
  afterAdd(vector, result, vecToAdd) {
    console.log(`result of add was: {${result.x}, ${result.y}}`);

    // don't modify the result so return nothing
  }
}

let modifyResultPlugin = {
  afterAdd(vector, result, vecToAdd) {
    // modify the result of the `add` function
    return kontra.vector(result.x * 2, result.y * 2);
  }
}</code></pre>

        </section>





        <section>
          <h2 id="unregsiter"><a href="#unregsiter" class="section-link">kontra.plugin&#8203;.unregsiter(object, plugin)<span aria-hidden="true">#</span></a></h2>

          <dl>
            <dt><strong>object</strong> <em>{string}</em></dt>
            <dd>Kontra object to attach plugin to.</dd>
            <dt><strong>plugin</strong> <em>{object}</em></dt>
            <dd>Plugin object with before and after functions.</dd>
          </dl>

          <p>Unregister a plugin and remove all its before and after functions from the intercepted Kontra object.</p>

        </section>

      </div>
    </main>
  </div>

</body>
</html>