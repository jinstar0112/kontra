{"version":3,"sources":["core.js","gameLoop.js","keyboard.js","pool.js","quadtree.js","sprite.js","spriteSheet.js","store.js","tileEngine.js"],"names":["kontra","document","init","properties","isString","canvas","this","getElementById","isCanvas","getElementsByTagName","error","ReferenceError","logError","context","getContext","game","width","height","message","console","stack","noop","isArray","Array","value","isNumber","isImage","HTMLImageElement","HTMLCanvasElement","window","timestamp","performance","now","Date","getTime","gameLoop","Object","create","prototype","set","update","render","isStopped","_accumulator","_delta","fps","frame","_this","_rAF","requestAnimationFrame","bind","_now","_dt","_last","start","stop","cancelAnimationFrame","normalizeKeyCode","e","which","keyCode","normalizeKeys","keys","combination","trim","replace","modifier","i","modifierOrder","indexOf","push","toLowerCase","shiftKeys","join","getKeyCombination","key","keyMap","keydownEventHandler","split","pressedKeys","callbacks","preventDefault","keyupEventHandler","aliases","blurEventHandler",8,9,13,16,17,18,20,27,32,33,34,35,36,37,38,39,40,45,46,91,92,93,144,145,106,107,109,110,111,186,187,188,189,190,191,192,219,220,221,222,"String","fromCharCode","~","!","@","#","$","%","^","&","*","(",")","_","+",":","\"","<",">","?","|","plus","leftwindow","select","addEventListener","callback","SyntaxError","unbind","undefined","pressed","pool","obj","createProperties","isAlive","objects","size","maxSize","Infinity","lastIndex","inUse","fill","length","unshift","get","x","getAliveObjects","slice","clear","dt","index","Math","max","j","quadtree","depth","maxDepth","maxObjects","isBranchNode","parentNode","bounds","y","subnodes","object","indices","node","_getIndex","apply","add","arguments","_addToSubnode","_split","verticalMidpoint","horizontalMidpoint","position","intersectsTopQuadrants","intersectsBottomQuadrants","subWidth","subHeight","strokeStyle","strokeRect","excludedProperties","vector","clamp","xMin","yMin","xMax","yMax","_xMin","_xMax","_yMin","_yMax","_x","_y","defineProperties","min","sprite","advanceSprite","velocity","acceleration","timeToLive","drawRect","fillStyle","color","fillRect","drawImage","image","advanceAnimation","currentAnimation","drawAnimation","playAnimation","name","animations","dx","dy","ddx","ddy","advance","draw","prop","hasOwnProperty",{"end":{"file":"?","comments_before":[],"nlb":false,"endpos":35466,"pos":35465,"col":8,"line":1297,"value":"x","type":"name"},"start":{"file":"?","comments_before":[],"nlb":false,"endpos":35466,"pos":35465,"col":8,"line":1297,"value":"x","type":"name"},"name":"x"},"collidesWith","animation","spriteSheet","frames","frameSpeed","currentFrame","row","framesPerRow","col","play","pause","frameWidth","frameHeight","createAnimations","sequence","_parseFrames","consecutiveFrames","map","Number","direction","localStorage","canUse","store","remove","setItem","JSON","stringify","getItem","parse","removeItem","tileEngine","tileWidth","tileHeight","canvasWidth","canvasHeight","_offscreenCanvas","createElement","_offscreenContext","mapWidth","mapHeight","sxMax","syMax","layers","_layerOrder","tilesets","sx","sy","addTileset","firstGrid","numTiles","lastTileset","tiles","lastGrid","sort","a","b","addLayer","data","r","c","zIndex","_preRenderImage","layerCollidesWith","_getRow","_getCol","endRow","endCol","tileAtLayer","renderLayer","tile","tileset","tileOffset","layer","startX","startY","viewWidth","ceil","viewHeight","count","_getTileset","currTile","len"],"mappings":"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","file":"kontra.min.js","sourcesContent":["/* global console */\n\nvar kontra = (function(kontra, document) {\n  'use strict';\n\n  /**\n   * Set up the canvas.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties for the game.\n   * @param {string|Canvas} properties.canvas - Main canvas ID or Element for the game.\n   */\n  kontra.init = function init(properties) {\n    properties = properties || {};\n\n    if (kontra.isString(properties.canvas)) {\n      this.canvas = document.getElementById(properties.canvas);\n    }\n    else if (kontra.isCanvas(properties.canvas)) {\n      this.canvas = properties.canvas;\n    }\n    else {\n      this.canvas = document.getElementsByTagName('canvas')[0];\n\n      if (!this.canvas) {\n        var error = new ReferenceError('No canvas element found.');\n        kontra.logError(error, 'You must provide a canvas element for the game.');\n        return;\n      }\n    }\n\n    this.context = this.canvas.getContext('2d');\n    this.game = {\n      width: this.canvas.width,\n      height: this.canvas.height\n    };\n  };\n\n  /**\n   * Throw an error message to the user with readable formating.\n   * @memberof kontra\n   *\n   * @param {Error}  error - Error object.\n   * @param {string} message - Error message.\n   */\n  kontra.logError = function logError(error, message) {\n    console.error('Kontra: ' + message + '\\n\\t' + error.stack);\n  };\n\n  /**\n   * Noop function.\n   * @memberof kontra\n   */\n  kontra.noop = function noop() {};\n\n  /**\n   * Determine if a value is an Array.\n   * @memberof kontra\n   *\n   * @param {*} value - Value to test.\n   *\n   * @returns {boolean}\n   */\n  kontra.isArray = Array.isArray;\n\n  /**\n   * Determine if a value is a String.\n   * @memberof kontra\n   *\n   * @param {*} value - Value to test.\n   *\n   * @returns {boolean}\n   */\n  kontra.isString = function isString(value) {\n    return typeof value === 'string';\n  };\n\n  /**\n   * Determine if a value is a Number.\n   * @memberof kontra\n   *\n   * @param {*} value - Value to test.\n   *\n   * @returns {boolean}\n   */\n  kontra.isNumber = function isNumber(value) {\n    return typeof value === 'number';\n  };\n\n  /**\n   * Determine if a value is an Image.\n   * @memberof kontra\n   *\n   * @param {*} value - Value to test.\n   *\n   * @returns {boolean}\n   */\n  kontra.isImage = function isImage(value) {\n    return value instanceof HTMLImageElement;\n  };\n\n  /**\n   * Determine if a value is a Canvas.\n   * @memberof kontra\n   *\n   * @param {*} value - Value to test.\n   *\n   * @returns {boolean}\n   */\n  kontra.isCanvas = function isCanvas(value) {\n    return value instanceof HTMLCanvasElement;\n  };\n\n  return kontra;\n})(kontra || {}, document);","var kontra = (function(kontra, window) {\n  'use strict';\n\n  /**\n   * Get the current time. Uses the User Timing API if it's available or defaults to using\n   * Date().getTime()\n   * @private\n   *\n   * @returns {number}\n   */\n  kontra.timestamp = (function() {\n    if (window.performance && window.performance.now) {\n      return function timestampPerformance() {\n        return window.performance.now();\n      };\n    }\n    else {\n      return function timestampDate() {\n        return new Date().getTime();\n      };\n    }\n  })();\n\n  /**\n   * Game loop that updates and renders the game every frame.\n   * @memberof kontra\n   *\n   * @see kontra.gameLoop.prototype.set for list of parameters.\n   */\n  kontra.gameLoop = function(properties) {\n    var gameLoop = Object.create(kontra.gameLoop.prototype);\n    gameLoop.set(properties);\n\n    return gameLoop;\n  };\n\n  kontra.gameLoop.prototype = {\n    /**\n     * Set properties on the game loop.\n     * @memberof kontra.gameLoop\n     *\n     * @param {object}   properties - Configure the game loop.\n     * @param {number}   [properties.fps=60] - Desired frame rate.\n     * @param {function} properties.update - Function called to update the game.\n     * @param {function} properties.render - Function called to render the game.\n     */\n    set: function set(properties) {\n      properties = properties || {};\n\n      // check for required functions\n      if (typeof properties.update !== 'function' || typeof properties.render !== 'function') {\n        var error = new ReferenceError('Required functions not found');\n        kontra.logError(error, 'You must provide update() and render() functions to create a game loop.');\n        return;\n      }\n\n      this.isStopped = false;\n\n      // animation variables\n      this._accumulator = 0;\n      this._delta = 1E3 / (properties.fps || 60);\n\n      this.update = properties.update;\n      this.render = properties.render;\n    },\n\n    /**\n     * Called every frame of the game loop.\n     * @memberof kontra.gameLoop\n     */\n    frame: function frame() {\n      var _this = this;\n\n      _this._rAF = requestAnimationFrame(_this.frame.bind(_this));\n\n      _this._now = kontra.timestamp();\n      _this._dt = _this._now - _this._last;\n      _this._last = _this._now;\n\n      // prevent updating the game with a very large dt if the game were to lose focus\n      // and then regain focus later\n      if (_this._dt > 1E3) {\n        return;\n      }\n\n      _this._accumulator += _this._dt;\n\n      while (_this._accumulator >= _this._delta) {\n        _this.update(_this._delta / 1E3);\n\n        _this._accumulator -= _this._delta;\n      }\n\n      _this.render();\n    },\n\n    /**\n     * Start the game loop.\n     * @memberof kontra.gameLoop\n     */\n    start: function start() {\n      this._last = kontra.timestamp();\n      this.isStopped = false;\n      requestAnimationFrame(this.frame.bind(this));\n    },\n\n    /**\n     * Stop the game loop.\n     */\n    stop: function stop() {\n      this.isStopped = true;\n      cancelAnimationFrame(this._rAF);\n    }\n  };\n\n  return kontra;\n})(kontra || {}, window);","/*jshint -W084 */\n\nvar kontra = (function(kontra, window) {\n  'use strict';\n\n  var callbacks = {};\n  var pressedKeys = {};\n\n  var keyMap = {\n    // named keys\n    8: 'backspace',\n    9: 'tab',\n    13: 'enter',\n    16: 'shift',\n    17: 'ctrl',\n    18: 'alt',\n    20: 'capslock',\n    27: 'esc',\n    32: 'space',\n    33: 'pageup',\n    34: 'pagedown',\n    35: 'end',\n    36: 'home',\n    37: 'left',\n    38: 'up',\n    39: 'right',\n    40: 'down',\n    45: 'insert',\n    46: 'delete',\n    91: 'leftwindow',\n    92: 'rightwindow',\n    93: 'select',\n    144: 'numlock',\n    145: 'scrolllock',\n\n    // special characters\n    106: '*',\n    107: '+',\n    109: '-',\n    110: '.',\n    111: '/',\n    186: ';',\n    187: '=',\n    188: ',',\n    189: '-',\n    190: '.',\n    191: '/',\n    192: '`',\n    219: '[',\n    220: '\\\\',\n    221: ']',\n    222: '\\''\n  };\n\n  // alpha keys\n  for (var i = 0; i < 26; i++) {\n    keyMap[65+i] = String.fromCharCode(65+i).toLowerCase();\n  }\n  // numeric keys\n  for (i = 0; i < 10; i++) {\n    keyMap[48+i] = ''+i;\n  }\n  // f keys\n  for (i = 1; i < 20; i++) {\n    keyMap[111+i] = 'f'+i;\n  }\n  // keypad\n  for (i = 0; i < 10; i++) {\n    keyMap[96+i] = 'numpad'+i;\n  }\n\n  // shift keys mapped to their non-shift equivalent\n  var shiftKeys = {\n    '~': '`',\n    '!': '1',\n    '@': '2',\n    '#': '3',\n    '$': '4',\n    '%': '5',\n    '^': '6',\n    '&': '7',\n    '*': '8',\n    '(': '9',\n    ')': '0',\n    '_': '-',\n    '+': '=',\n    ':': ';',\n    '\"': '\\'',\n    '<': ',',\n    '>': '.',\n    '?': '/',\n    '|': '\\\\',\n    'plus': '='\n  };\n\n  // aliases modifier keys to their actual key for keyup event\n  var aliases = {\n    'leftwindow': 'meta',  // mac\n    'select': 'meta'       // mac\n  };\n\n  // modifier order for combinations\n  var modifierOrder = ['meta', 'ctrl', 'alt', 'shift'];\n\n  window.addEventListener('keydown', keydownEventHandler);\n  window.addEventListener('keyup', keyupEventHandler);\n  window.addEventListener('blur', blurEventHandler);\n\n  /**\n   * Object for using the keyboard.\n   */\n  kontra.keys = {};\n\n  /**\n   * Register a function to be called on a keyboard keys.\n   * Please note that not all keyboard combinations can be executed due to ghosting.\n   * @memberof kontra.keys\n   *\n   * @param {string|string[]} keys - keys combination string(s).\n   *\n   * @throws {SyntaxError} If callback is not a function.\n   */\n  kontra.keys.bind = function bindKey(keys, callback) {\n    if (typeof callback !== 'function') {\n      var error = new SyntaxError('Invalid function.');\n      kontra.logError(error, 'You must provide a function as the second parameter.');\n      return;\n    }\n\n    keys = (kontra.isArray(keys) ? keys : [keys]);\n\n    for (var i = 0, key; key = keys[i]; i++) {\n      var combination = normalizeKeys(key);\n\n      callbacks[combination] = callback;\n    }\n  };\n\n  /**\n   * Remove the callback function for a key combination.\n   * @memberof kontra.keys\n   *\n   * @param {string|string[]} keys - keys combination string.\n   */\n  kontra.keys.unbind = function unbindKey(keys) {\n    keys = (kontra.isArray(keys) ? keys : [keys]);\n\n    for (var i = 0, key; key = keys[i]; i++) {\n      var combination = normalizeKeys(key);\n\n      callbacks[combination] = undefined;\n    }\n  };\n\n  /**\n   * Returns whether a key is pressed.\n   * @memberof kontra.keys\n   *\n   * @param {string} keys - Keys combination string.\n   *\n   * @returns {boolean}\n   */\n  kontra.keys.pressed = function keyPressed(keys) {\n    var combination = normalizeKeys(keys);\n    var pressed = true;\n\n    // loop over each key in the combination and verify that it is pressed\n    keys = combination.split('+');\n    for (var i = 0, key; key = keys[i]; i++) {\n      pressed = pressed && !!pressedKeys[key];\n    }\n\n    return pressed;\n  };\n\n  /**\n   * Normalize the event keycode\n   * @private\n   *\n   * @param {Event} e\n   *\n   * @returns {number}\n   */\n  function normalizeKeyCode(e) {\n    return (typeof e.which === 'number' ? e.which : e.keyCode);\n  }\n\n  /**\n   * Normalize keys combination order.\n   * @private\n   *\n   * @param {string} keys - keys combination string.\n   *\n   * @returns {string} Normalized combination.\n   *\n   * @example\n   * normalizeKeys('c+ctrl');  //=> 'ctrl+c'\n   * normalizeKeys('shift+++meta+alt');  //=> 'meta+alt+shift+plus'\n   */\n  function normalizeKeys(keys) {\n    var combination = [];\n\n    // handle '++' combinations\n    keys = keys.trim().replace('++', '+plus');\n\n    // put modifiers in the correct order\n    for (var i = 0, modifier; modifier = modifierOrder[i]; i++) {\n\n      // check for the modifier\n      if (keys.indexOf(modifier) !== -1) {\n        combination.push(modifier);\n        keys = keys.replace(modifier, '');\n      }\n    }\n\n    // remove all '+'s to leave only the last key\n    keys = keys.replace(/\\+/g, '').toLowerCase();\n\n    // check for shift key\n    if (shiftKeys[keys]) {\n      combination.push('shift+'+shiftKeys[keys]);\n    }\n    else if(keys) {\n      combination.push(keys);\n    }\n\n    return combination.join('+');\n  }\n\n  /**\n   * Get the key combination from an event.\n   * @private\n   *\n   * @param {Event} e\n   *\n   * @return {string} normalized combination.\n   */\n  function getKeyCombination(e) {\n    var combination = [];\n\n    // check for modifiers\n    for (var i = 0, modifier; modifier = modifierOrder[i]; i++) {\n      if (e[modifier+'Key']) {\n        combination.push(modifier);\n      }\n    }\n\n    var key = keyMap[normalizeKeyCode(e)];\n\n    // prevent duplicate keys from being added to the combination\n    // for example 'ctrl+ctrl' since ctrl is both a modifier and\n    // a regular key\n    if (combination.indexOf(key) === -1) {\n      combination.push(key);\n    }\n\n    return combination.join('+');\n  }\n\n  /**\n   * Execute a function that corresponds to a keyboard combination.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function keydownEventHandler(e) {\n    var combination = getKeyCombination(e);\n\n    // set pressed keys\n    for (var i = 0, keys = combination.split('+'), key; key = keys[i]; i++) {\n      pressedKeys[key] = true;\n    }\n\n    if (callbacks[combination]) {\n      callbacks[combination](e, combination);\n      e.preventDefault();\n    }\n  }\n\n  /**\n   * Set the released key to not being pressed.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function keyupEventHandler(e) {\n    var key = keyMap[normalizeKeyCode(e)];\n    pressedKeys[key] = false;\n\n    if (aliases[key]) {\n      pressedKeys[ aliases[key] ] = false;\n    }\n  }\n\n  /**\n   * Reset pressed keys.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function blurEventHandler(e) {\n    pressedKeys = {};\n  }\n\n  return kontra;\n})(kontra || {}, window);","/*jshint -W084 */\n\nvar kontra = (function(kontra) {\n  'use strict';\n\n  /**\n   * Object pool. The pool will grow in size to accommodate as many objects as are needed.\n   * Unused items are at the front of the pool and in use items are at the of the pool.\n   * @memberof kontra\n   *\n   * @see kontra.pool.prototype.set for list of parameters.\n   */\n  kontra.pool = function(properties) {\n    var pool = Object.create(kontra.pool.prototype);\n    pool.set(properties);\n\n    return pool;\n  };\n\n  kontra.pool.prototype = {\n    /**\n     * Set properties on the pool.\n     * @memberof kontra.pool\n     *\n     * @param {object} properties - Properties of the pool.\n     * @param {object} properties.create - Function that returns the object to use in the pool.\n     * @param {object} properties.createProperties - Properties that will be passed to the create function.\n     * @param {number} properties.maxSize - The maximum size that the pool will grow to.\n     * @param {boolean} properties.fill - Fill the pool to max size instead of slowly growing.\n     *\n     * Objects inside the pool must implement <code>render()</code>, <code>update()</code>,\n     * <code>set()</code>, and <code>isAlive()</code> functions.\n     */\n    set: function set(properties) {\n      properties = properties || {};\n\n      var error, obj;\n\n      if (typeof properties.create !== 'function') {\n        error = new SyntaxError('Required function not found.');\n        kontra.logError(error, 'Parameter \\'create\\' must be a function that returns an object.');\n        return;\n      }\n\n      // bind the create function to always use the create properties\n      this.create = properties.create.bind(this, properties.createProperties || {});\n\n      // ensure objects for the pool have required functions\n      obj = this.create();\n\n      if (!obj || typeof obj.render !== 'function' || typeof obj.update !== 'function' ||\n          typeof obj.set !== 'function' || typeof obj.isAlive !== 'function') {\n        error = new SyntaxError('Create object required functions not found.');\n        kontra.logError(error, 'Objects to be pooled must implement render(), update(), set() and isAlive() functions.');\n        return;\n      }\n\n      // start the pool with an object\n      this.objects = [obj];\n      this.size = 1;\n      this.maxSize = properties.maxSize || Infinity;\n      this.lastIndex = 0;\n      this.inUse = 0;\n\n      // fill the pool\n      if (properties.fill) {\n        while (this.objects.length < this.maxSize) {\n          this.objects.unshift(this.create());\n        }\n      }\n    },\n\n    /**\n     * Get an object from the pool.\n     * @memberof kontra.pool\n     *\n     * @param {object} properties - Properties to pass to object.set().\n     */\n    get: function get(properties) {\n      properties = properties || {};\n\n      var _this = this;\n\n      // the pool is out of objects if the first object is in use and it can't grow\n      if (_this.objects[0].isAlive()) {\n        if (_this.size === _this.maxSize) {\n          return;\n        }\n        // 'double' the size of the array by filling it with twice as many objects\n        else {\n          for (var x = 0; x < _this.size && _this.objects.length < _this.maxSize; x++) {\n            _this.objects.unshift(_this.create());\n          }\n\n          _this.size = _this.objects.length;\n          _this.lastIndex = _this.size - 1;\n        }\n      }\n\n      // save off first object in pool to reassign to last object after unshift\n      var obj = _this.objects[0];\n      obj.set(properties);\n\n      // unshift the array\n      for (var i = 1; i < _this.size; i++) {\n        _this.objects[i-1] = _this.objects[i];\n      }\n\n      _this.objects[_this.lastIndex] = obj;\n      _this.inUse++;\n    },\n\n    /**\n     * Return all objects that are alive from the pool.\n     * @memberof kontra.pool\n     *\n     * @returns {object[]}\n     */\n    getAliveObjects: function getAliveObjects() {\n      return this.objects.slice(this.objects.length - this.inUse);\n    },\n\n    /**\n     * Clear the object pool.\n     * @memberof kontra.pool\n     */\n    clear: function clear() {\n      this.inUse = 0;\n      this.size = 1;\n      this.lastIndex = 0;\n      this.objects.length = 0;\n      this.objects.push(this.create({}));\n    },\n\n    /**\n     * Update all alive pool objects.\n     * @memberof kontra.pool\n     *\n     * @param {number} dt - Time since last update.\n     */\n    update: function update(dt) {\n      var i = this.lastIndex;\n      var obj;\n\n      // If the user kills an object outside of the update cycle, the pool won't know of\n      // the change until the next update and inUse won't be decremented. If the user then\n      // gets an object when inUse is the same size as objects.length, inUse will increment\n      // and this statement will evaluate to -1.\n      //\n      // I don't like having to go through the pool to kill an object as it forces you to\n      // know which object came from which pool. Instead, we'll just prevent the index from\n      // going below 0 and accept the fact that inUse may be out of sync for a frame.\n      var index = Math.max(this.objects.length - this.inUse, 0);\n\n      // only iterate over the objects that are alive\n      while (i >= index) {\n        obj = this.objects[i];\n\n        obj.update(dt);\n\n        // if the object is dead, move it to the front of the pool\n        if (!obj.isAlive()) {\n\n          // push an object from the middle of the pool to the front of the pool\n          // without returning a new array through Array#splice to avoid garbage\n          // collection of the old array\n          // @see http://jsperf.com/object-pools-array-vs-loop\n          for (var j = i; j > 0; j--) {\n            this.objects[j] = this.objects[j-1];\n          }\n\n          this.objects[0] = obj;\n          this.inUse--;\n          index++;\n        }\n        else {\n          i--;\n        }\n      }\n    },\n\n    /**\n     * render all alive pool objects.\n     * @memberof kontra.pool\n     */\n    render: function render() {\n      var index = Math.max(this.objects.length - this.inUse, 0);\n\n      for (var i = this.lastIndex; i >= index; i--) {\n        this.objects[i].render();\n      }\n    }\n  };\n\n  return kontra;\n})(kontra || {});","/*jshint -W084 */\n\nvar kontra = (function(kontra, undefined) {\n  'use strict';\n\n  /**\n   * A quadtree for 2D collision checking. The quadtree acts like an object pool in that it\n   * will create subnodes as objects are needed but it won't clean up the subnodes when it\n   * collapses to avoid garbage collection.\n   * @memberof kontra\n   *\n   * @see kontra.quadtree.prototype.set for list of parameters.\n   *L\n   * The quadrant indices are numbered as follows (following a z-order curve):\n   *     |\n   *  0  |  1\n   * ----+----\n   *  2  |  3\n   *     |\n   */\n  kontra.quadtree = function(properties) {\n    var quadtree = Object.create(kontra.quadtree.prototype);\n    quadtree.set(properties);\n\n    return quadtree;\n  };\n\n  kontra.quadtree.prototype = {\n    /**\n     * Set properties on the quadtree.\n     * @memberof kontra.quadtree\n     *\n     * @param {number} [depth=0] - Current node depth.\n     * @param {number} [maxDepth=3] - Maximum node depths the quadtree can have.\n     * @param {number} [maxObjects=25] - Maximum number of objects a node can support before splitting.\n     * @param {object} [parentNode] - The node that contains this node.\n     * @param {object} [bounds] - The 2D space this node occupies.\n     */\n    set: function set(properties) {\n      properties = properties || {};\n\n      this.depth = properties.depth || 0;\n      this.maxDepth = properties.maxDepth || 3;\n      this.maxObjects = properties.maxObjects || 25;\n\n      // since we won't clean up any subnodes, we need to keep track of which nodes are\n      // currently the leaf node so we know which nodes to add objects to\n      this.isBranchNode = false;\n\n      this.parentNode = properties.parentNode;\n\n      this.bounds = properties.bounds || {\n        x: 0,\n        y: 0,\n        width: kontra.game.width,\n        height: kontra.game.height\n      };\n\n      this.objects = [];\n      this.subnodes = [];\n    },\n\n    /**\n     * Clear the quadtree\n     * @memberof kontra.quadtree\n     */\n    clear: function clear() {\n      if (this.isBranchNode) {\n        for (var i = 0; i < 4; i++) {\n          this.subnodes[i].clear();\n        }\n      }\n\n      this.isBranchNode = false;\n      this.objects.length = 0;\n    },\n\n    /**\n     * Find the leaf node the object belongs to and get all objects that are part of\n     * that node.\n     * @memberof kontra.quadtree\n     *\n     * @param {object} object - Object to use for finding the leaf node.\n     *\n     * @returns {object[]} A list of objects in the same leaf node as the object.\n     */\n    get: function get(object) {\n      var node = this;\n      var objects = [];\n      var indices, index;\n\n      // traverse the tree until we get to a leaf node\n      while (node.subnodes.length && this.isBranchNode) {\n        indices = this._getIndex(object);\n\n        for (var i = 0, length = indices.length; i < length; i++) {\n          index = indices[i];\n\n          objects.push.apply(objects, this.subnodes[index].get(object));\n        }\n\n        return objects;\n      }\n\n      return node.objects;\n    },\n\n    /**\n     * Add an object to the quadtree. Once the number of objects in the node exceeds\n     * the maximum number of objects allowed, it will split and move all objects to their\n     * corresponding subnodes.\n     * @memberof kontra.quadtree\n     */\n    add: function add() {\n      var _this = this;\n      var i, object, obj, indices, index;\n\n      for (var j = 0, length = arguments.length; j < length; j++) {\n        object = arguments[j];\n\n        // add a group of objects separately\n        if (kontra.isArray(object)) {\n          _this.add.apply(this, object);\n\n          continue;\n        }\n\n        // current node has subnodes, so we need to add this object into a subnode\n        if (_this.subnodes.length && _this.isBranchNode) {\n          _this._addToSubnode(object);\n\n          continue;\n        }\n\n        // this node is a leaf node so add the object to it\n        _this.objects.push(object);\n\n        // split the node if there are too many objects\n        if (_this.objects.length > _this.maxObjects && _this.depth < _this.maxDepth) {\n          _this._split();\n\n          // move all objects to their corresponding subnodes\n          for (i = 0; obj = _this.objects[i]; i++) {\n            _this._addToSubnode(obj);\n          }\n\n          _this.objects.length = 0;\n        }\n      }\n    },\n\n    /**\n     * Add an object to a subnode.\n     * @memberof kontra.quadtree\n     * @private\n     *\n     * @param {object} object - Object to add into a subnode\n     */\n    _addToSubnode: function _addToSubnode(object) {\n      var indices = this._getIndex(object);\n\n      // add the object to all subnodes it intersects\n      for (var i = 0, length = indices.length; i < length; i++) {\n        this.subnodes[ indices[i] ].add(object);\n      }\n    },\n\n    /**\n     * Determine which subnodes the object intersects with.\n     * @memberof kontra.quadtree\n     * @private\n     *\n     * @param {object} object - Object to check.\n     *\n     * @returns {number[]} List of all subnodes object intersects.\n     */\n    _getIndex: function getIndex(object) {\n      var indices = [];\n\n      var verticalMidpoint = this.bounds.x + this.bounds.width / 2;\n      var horizontalMidpoint = this.bounds.y + this.bounds.height / 2;\n\n      // handle non-kontra.sprite objects as well as kontra.sprite objects\n      var x = (object.x !== undefined ? object.x : object.position.x);\n      var y = (object.y !== undefined ? object.y : object.position.y);\n\n      // save off quadrant checks for reuse\n      var intersectsTopQuadrants = y < horizontalMidpoint && y + object.height >= this.bounds.y;\n      var intersectsBottomQuadrants = y + object.height >= horizontalMidpoint && y < this.bounds.y + this.bounds.height;\n\n      // object intersects with the left quadrants\n      if (x < verticalMidpoint && x + object.width >= this.bounds.x) {\n        if (intersectsTopQuadrants) {  // top left\n          indices.push(0);\n        }\n\n        if (intersectsBottomQuadrants) {  // bottom left\n          indices.push(2);\n        }\n      }\n\n      // object intersects with the right quadrants\n      if (x + object.width >= verticalMidpoint && x < this.bounds.x + this.bounds.width) {  // top right\n        if (intersectsTopQuadrants) {\n          indices.push(1);\n        }\n\n        if (intersectsBottomQuadrants) {  // bottom right\n          indices.push(3);\n        }\n      }\n\n      return indices;\n    },\n\n    /**\n     * Split the node into four subnodes.\n     * @memberof kontra.quadtree\n     * @private\n     */\n    _split: function split() {\n      this.isBranchNode = true;\n\n      // only split if we haven't split before\n      if (this.subnodes.length) {\n        return;\n      }\n\n      var subWidth = this.bounds.width / 2 | 0;\n      var subHeight = this.bounds.height / 2 | 0;\n      var x = this.bounds.x;\n      var y = this.bounds.y;\n\n      for (var i = 0; i < 4; i++) {\n        this.subnodes[i] = kontra.quadtree({\n          bounds: {\n            x: x + (i % 2 === 1 ? subWidth : 0),  // nodes 1 and 3\n            y: y + (i >= 2 ? subHeight : 0),      // nodes 2 and 3\n            width: subWidth,\n            height: subHeight\n          },\n          depth: this.depth+1,\n          maxDepth: this.maxDepth,\n          maxObjects: this.maxObjects,\n          parentNode: this\n        });\n      }\n    },\n\n    /**\n     * Draw the quadtree. Useful for visual debugging.\n     * @memberof kontra.quadtree\n     */\n    render: function() {\n      // don't draw empty leaf nodes, always draw branch nodes and the first node\n      if (this.objects.length || this.depth === 0 ||\n          (this.parentNode && this.parentNode.isBranchNode)) {\n\n        kontra.context.strokeStyle = 'red';\n        kontra.context.strokeRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);\n\n        if (this.subnodes.length) {\n          for (var i = 0; i < 4; i++) {\n            this.subnodes[i].render();\n          }\n        }\n      }\n    }\n  };\n\n  return kontra;\n})(kontra || {});","var kontra = (function(kontra, Math, undefined) {\n  'use strict';\n\n  // prevent these properties from being set at the end of kontra.sprite.set()\n  var excludedProperties = [\n    'x',\n    'y',\n    'dx',\n    'dy',\n    'ddx',\n    'ddy',\n    'timeToLive',\n    'context',\n    'image',\n    'animations',\n    'color',\n    'width',\n    'height'\n  ];\n\n  /**\n   * A vector for 2D space.\n   * @memberof kontra\n   *\n   * @see kontra.vector.prototype.set for list of parameters.\n   */\n  kontra.vector = function(x, y) {\n    var vector = Object.create(kontra.vector.prototype);\n    vector.set(x, y);\n\n    return vector;\n  };\n\n  kontra.vector.prototype = {\n    /**\n     * Set the vectors x and y position.\n     * @memberof kontra.vector\n     *\n     * @param {number} x=0 - Center x coordinate.\n     * @param {number} y=0 - Center y coordinate.\n     *\n     * @returns {vector}\n     */\n    set: function set(x, y) {\n      this.x = x || 0;\n      this.y = y || 0;\n\n      return this;\n    },\n\n    /**\n     * Add a vector to this vector.\n     * @memberof kontra.vector\n     *\n     * @param {vector} vector - Vector to add.\n     * @param {number} dt=1 - Time since last update.\n     */\n    add: function add(vector, dt) {\n      this.x += (vector.x || 0) * (dt || 1);\n      this.y += (vector.y || 0) * (dt || 1);\n    },\n\n    /**\n     * Clamp the vector between two points that form a rectangle.\n     * Please note that clamping will only work if the add function is called.\n     * @memberof kontra.vector\n     *\n     * @param {number} [xMin=-Infinity] - Min x value.\n     * @param {number} [yMin=Infinity] - Min y value.\n     * @param {number} [xMax=-Infinity] - Max x value.\n     * @param {number} [yMax=Infinity] - Max y value.\n     */\n    clamp: function clamp(xMin, yMin, xMax, yMax) {\n      this._xMin = (xMin !== undefined ? xMin : -Infinity);\n      this._xMax = (xMax !== undefined ? xMax : Infinity);\n      this._yMin = (yMin !== undefined ? yMin : -Infinity);\n      this._yMax = (yMax !== undefined ? yMax : Infinity);\n\n      // rename x and y so we can use them as getters and setters\n      this._x = this.x;\n      this._y = this.y;\n\n      // define getters to return the renamed x and y and setters to clamp their value\n      Object.defineProperties(this, {\n        x: {\n          get: function() {\n            return this._x;\n          },\n          set: function(value) {\n            this._x = Math.min( Math.max(value, this._xMin), this._xMax );\n          }\n        },\n        y: {\n          get: function() {\n            return this._y;\n          },\n          set: function(value) {\n            this._y = Math.min( Math.max(value, this._yMin), this._yMax );\n          }\n        }\n      });\n    }\n  };\n\n\n\n\n\n  /**\n   * A sprite with a position, velocity, and acceleration.\n   * @memberof kontra\n   * @requires kontra.vector\n   *\n   * @see kontra.sprite._prot.set for list of parameters.\n   */\n  kontra.sprite = function(properties) {\n    var sprite = Object.create(kontra.sprite.prototype);\n    sprite.set(properties);\n\n    return sprite;\n  };\n\n  kontra.sprite.prototype = {\n    /**\n     * Move the sprite by its velocity.\n     * @memberof kontra.sprite\n     *\n     * @param {number} dt - Time since last update.\n     */\n    advanceSprite: function advanceSprite(dt) {\n      this.velocity.add(this.acceleration, dt);\n      this.position.add(this.velocity, dt);\n\n      this.timeToLive--;\n    },\n\n    /**\n     * Draw a simple rectangle. Useful for prototyping.\n     * @memberof kontra.sprite\n     */\n    drawRect: function drawRect() {\n      this.context.fillStyle = this.color;\n      this.context.fillRect(this.position.x, this.position.y, this.width, this.height);\n    },\n\n    /**\n     * Draw the sprite.\n     * @memberof kontra.sprite\n     */\n    drawImage: function drawImage() {\n      this.context.drawImage(this.image, this.position.x, this.position.y);\n    },\n\n    /**\n     * Update the currently playing animation. Used when animations are passed to the sprite.\n     * @memberof kontra.sprite\n     *\n     * @param {number} dt - Time since last update.\n     */\n    advanceAnimation: function advanceAnimation(dt) {\n      this.advanceSprite(dt);\n\n      this.currentAnimation.update(dt);\n    },\n\n    /**\n     * Draw the currently playing animation. Used when animations are passed to the sprite.\n     * @memberof kontra.sprite\n     */\n    drawAnimation: function drawAnimation() {\n      this.currentAnimation.render({\n        context: this.context,\n        x: this.position.x,\n        y: this.position.y\n      });\n    },\n\n    /**\n     * Play an animation.\n     * @memberof kontra.sprite\n     *\n     * @param {string} name - Name of the animation to play.\n     */\n    playAnimation: function playAnimation(name) {\n      this.currentAnimation = this.animations[name];\n    },\n\n    /**\n     * Determine if the sprite is alive.\n     * @memberof kontra.sprite\n     *\n     * @returns {boolean}\n     */\n    isAlive: function isAlive() {\n      return this.timeToLive > 0;\n    },\n\n    /**\n     * Set properties on the sprite.\n     * @memberof kontra.sprite\n     *\n     * @param {object} properties - Properties to set on the sprite.\n     * @param {number} properties.x - X coordinate of the sprite.\n     * @param {number} properties.y - Y coordinate of the sprite.\n     * @param {number} [properties.dx] - Change in X position.\n     * @param {number} [properties.dy] - Change in Y position.\n     * @param {number} [properties.ddx] - Change in X velocity.\n     * @param {number} [properties.ddy] - Change in Y velocity.\n     *\n     * @param {number} [properties.timeToLive=0] - How may frames the sprite should be alive.\n     * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\n     *\n     * @param {Image|Canvas} [properties.image] - Image for the sprite.\n     *\n     * @param {object} [properties.animations] - Animations for the sprite instead of an image.\n     *\n     * @param {string} [properties.color] - If no image or animation is provided, use color to draw a rectangle for the sprite.\n     * @param {number} [properties.width] - Width of the sprite for drawing a rectangle.\n     * @param {number} [properties.height] - Height of the sprite for drawing a rectangle.\n     *\n     * @param {function} [properties.update] - Function to use to update the sprite.\n     * @param {function} [properties.render] - Function to use to render the sprite.\n     *\n     * If you need the sprite to live forever, or just need it to stay on screen until you\n     * decide when to kill it, you can set <code>timeToLive</code> to <code>Infinity</code>.\n     * Just be sure to set <code>timeToLive</code> to 0 when you want the sprite to die.\n     */\n    set: function set(properties) {\n      properties = properties || {};\n\n      var _this = this;\n\n      _this.position = (_this.position || kontra.vector()).set(properties.x, properties.y);\n      _this.velocity = (_this.velocity || kontra.vector()).set(properties.dx, properties.dy);\n      _this.acceleration = (_this.acceleration || kontra.vector()).set(properties.ddx, properties.ddy);\n\n      _this.timeToLive = properties.timeToLive || 0;\n      _this.context = properties.context || kontra.context;\n\n      // image sprite\n      if (kontra.isImage(properties.image) || kontra.isCanvas(properties.image)) {\n        _this.image = properties.image;\n        _this.width = properties.image.width;\n        _this.height = properties.image.height;\n\n        // change the advance and draw functions to work with images\n        _this.advance = _this.advanceSprite;\n        _this.draw = _this.drawImage;\n      }\n      // animation sprite\n      else if (properties.animations) {\n        _this.animations = properties.animations;\n\n        // default the current animation to the first one in the list\n        _this.currentAnimation = properties.animations[ Object.keys(properties.animations)[0] ];\n        _this.width = _this.currentAnimation.width;\n        _this.height = _this.currentAnimation.height;\n\n        // change the advance and draw functions to work with animations\n        _this.advance = _this.advanceAnimation;\n        _this.draw = _this.drawAnimation;\n      }\n      // rectangle sprite\n      else {\n        _this.color = properties.color;\n        _this.width = properties.width;\n        _this.height = properties.height;\n\n        // change the advance and draw functions to work with rectangles\n        _this.advance = _this.advanceSprite;\n        _this.draw = _this.drawRect;\n      }\n\n      // loop through all other properties an add them to the sprite\n      for (var prop in properties) {\n        if (properties.hasOwnProperty(prop) && excludedProperties.indexOf(prop) === -1) {\n          _this[prop] = properties[prop];\n        }\n      }\n    },\n\n    // define getter and setter shortcut functions to make it easier to work work with the\n    // position, velocity, and acceleration vectors.\n\n    /**\n     * Sprite position.x\n     * @memberof kontra.sprite\n     *\n     * @property {number} x\n     */\n    get x() {\n      return this.position.x;\n    },\n\n    /**\n     * Sprite position.y\n     * @memberof kontra.sprite\n     *\n     * @property {number} y\n     */\n    get y() {\n      return this.position.y;\n    },\n\n    /**\n     * Sprite velocity.x\n     * @memberof kontra.sprite\n     *\n     * @property {number} dx\n     */\n    get dx() {\n      return this.velocity.x;\n    },\n\n    /**\n     * Sprite velocity.y\n     * @memberof kontra.sprite\n     *\n     * @property {number} dy\n     */\n    get dy() {\n      return this.velocity.y;\n    },\n\n    /**\n     * Sprite acceleration.x\n     * @memberof kontra.sprite\n     *\n     * @property {number} ddx\n     */\n    get ddx() {\n      return this.acceleration.x;\n    },\n\n    /**\n     * Sprite acceleration.y\n     * @memberof kontra.sprite\n     *\n     * @property {number} ddy\n     */\n    get ddy() {\n      return this.acceleration.y;\n    },\n\n    set x(value) {\n      this.position.x = value;\n    },\n    set y(value) {\n      this.position.y = value;\n    },\n    set dx(value) {\n      this.velocity.x = value;\n    },\n    set dy(value) {\n      this.velocity.y = value;\n    },\n    set ddx(value) {\n      this.acceleration.x = value;\n    },\n    set ddy(value) {\n      this.acceleration.y = value;\n    },\n\n    /**\n     * Simple bounding box collision test.\n     * @memberof kontra.sprite\n     *\n     * @param {object} object - Object to check collision against.\n     *\n     * @returns {boolean} True if the objects collide, false otherwise.\n     */\n    collidesWith: function collidesWith(object) {\n      // handle non-kontra.sprite objects as well as kontra.sprite objects\n      var x = (object.x !== undefined ? object.x : object.position.x);\n      var y = (object.y !== undefined ? object.y : object.position.y);\n\n      if (this.position.x < x + object.width &&\n          this.position.x + this.width > x &&\n          this.position.y < y + object.height &&\n          this.position.y + this.height > y) {\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Update the sprites velocity and position.\n     * @memberof kontra.sprite\n     * @abstract\n     *\n     * @param {number} dt - Time since last update.\n     *\n     * This function can be overridden on a per sprite basis if more functionality\n     * is needed in the update step. Just call <code>this.advance()</code> when you need\n     * the sprite to update its position.\n     *\n     * @example\n     * sprite = kontra.sprite({\n     *   update: function update(dt) {\n     *     // do some logic\n     *\n     *     this.advance(dt);\n     *   }\n     * });\n     */\n    update: function update(dt) {\n      this.advance(dt);\n    },\n\n    /**\n     * Render the sprite.\n     * @memberof kontra.sprite.\n     * @abstract\n     *\n     * This function can be overridden on a per sprite basis if more functionality\n     * is needed in the render step. Just call <code>this.draw()</code> when you need the\n     * sprite to draw its image.\n     *\n     * @example\n     * sprite = kontra.sprite({\n     *   render: function render() {\n     *     // do some logic\n     *\n     *     this.draw();\n     *   }\n     * });\n     */\n    render: function render() {\n      this.draw();\n    }\n  };\n\n  return kontra;\n})(kontra || {}, Math);","/*jshint -W084 */\n\nvar kontra = (function(kontra, undefined) {\n  'use strict';\n\n  /**\n   * Single animation from a sprite sheet.\n   * @memberof kontra\n   *\n   * @see kontra.pool.prototype.set for list of parameters.\n   */\n  kontra.animation = function(properties) {\n    var animation = Object.create(kontra.animation.prototype);\n    animation.set(properties);\n\n    return animation;\n  };\n\n  kontra.animation.prototype = {\n    /**\n     * Set properties on the animation.\n     * @memberof kontra.animation\n     *\n     * @param {object} properties - Properties of the animation.\n     * @param {spriteSheet} properties.spriteSheet - Sprite sheet for the animation.\n     * @param {number[]} properties.frames - List of frames of the animation.\n     * @param {number}  properties.frameSpeed - Time to wait before transitioning the animation to the next frame.\n     */\n    set: function set(properties) {\n      properties = properties || {};\n\n      this.spriteSheet = properties.spriteSheet;\n      this.frames = properties.frames;\n      this.frameSpeed = properties.frameSpeed;\n\n      this.width = properties.spriteSheet.frame.width;\n      this.height = properties.spriteSheet.frame.height;\n\n      this.currentFrame = 0;\n      this._accumulator = 0;\n      this.update = this.advance;\n      this.render = this.draw;\n    },\n\n    /**\n     * Update the animation. Used when the animation is not paused or stopped.\n     * @memberof kontra.animation\n     * @private\n     *\n     * @param {number} dt=1 - Time since last update.\n     */\n    advance: function advance(dt) {\n      // normalize dt to work with milliseconds as a decimal or an integer\n      dt = (dt < 1 ? dt * 1E3 : dt) || 1;\n\n      this._accumulator += dt;\n\n      // update to the next frame if it's time\n      while (this._accumulator >= this.frameSpeed) {\n        this.currentFrame = ++this.currentFrame % this.frames.length;\n\n        this._accumulator -= this.frameSpeed;\n      }\n    },\n\n    /**\n     * Draw the current frame. Used when the animation is not stopped.\n     * @memberof kontra.animation\n     * @private\n     *\n     * @param {object} properties - How to draw the animation.\n     * @param {number} properties.x - X position to draw.\n     * @param {number} properties.y - Y position to draw.\n     * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\n     */\n    draw: function draw(properties) {\n      properties = properties || {};\n\n      var context = properties.context || kontra.context;\n\n      // get the row and col of the frame\n      var row = this.frames[this.currentFrame] / this.spriteSheet.framesPerRow | 0;\n      var col = this.frames[this.currentFrame] % this.spriteSheet.framesPerRow | 0;\n\n      context.drawImage(\n        this.spriteSheet.image,\n        col * this.spriteSheet.frame.width, row * this.spriteSheet.frame.height,\n        this.spriteSheet.frame.width, this.spriteSheet.frame.height,\n        properties.x, properties.y,\n        this.spriteSheet.frame.width, this.spriteSheet.frame.height\n      );\n    },\n\n    /**\n     * Play the animation.\n     * @memberof kontra.animation\n     */\n    play: function play() {\n      // restore references to update and render functions only if overridden\n      this.update = this.advance;\n      this.render = this.draw;\n    },\n\n    /**\n     * Stop the animation and prevent update and render.\n     * @memberof kontra.animation\n     */\n    stop: function stop() {\n\n      // instead of putting an if statement in both render/update functions that checks\n      // a variable to determine whether to render or update, we can just reassign the\n      // functions to noop and save processing time in the game loop.\n      // @see http://jsperf.com/boolean-check-vs-noop\n      this.update = kontra.noop;\n      this.render = kontra.noop;\n    },\n\n    /**\n     * Pause the animation and prevent update.\n     * @memberof kontra.animation\n     */\n    pause: function pause() {\n      this.update = kontra.noop;\n    }\n  };\n\n\n\n\n\n\n  /**\n   * Create a sprite sheet from an image.\n   * @memberof kontra\n   *\n   * @see kontra.spriteSheet.prototype.set for list of parameters.\n   */\n  kontra.spriteSheet = function(properties) {\n    var spriteSheet = Object.create(kontra.spriteSheet.prototype);\n    spriteSheet.set(properties);\n\n    return spriteSheet;\n  };\n\n  kontra.spriteSheet.prototype = {\n    /**\n     * Set properties on the spriteSheet.\n     * @memberof kontra\n     * @constructor\n     *\n     * @param {object} properties - Configure the sprite sheet.\n     * @param {Image|Canvas} properties.image - Image for the sprite sheet.\n     * @param {number} properties.frameWidth - Width (in px) of each frame.\n     * @param {number} properties.frameHeight - Height (in px) of each frame.\n     * @param {object} properties.animations - Animations to create from the sprite sheet.\n     */\n    set: function set(properties) {\n      properties = properties || {};\n\n      this.animations = {};\n\n      if (kontra.isImage(properties.image) || kontra.isCanvas(properties.image)) {\n        this.image = properties.image;\n        this.frame = {\n          width: properties.frameWidth,\n          height: properties.frameHeight\n        };\n\n        this.framesPerRow = properties.image.width / properties.frameWidth | 0;\n      }\n      else {\n        var error = new SyntaxError('Invalid image.');\n        kontra.logError(error, 'You must provide an Image for the SpriteSheet.');\n        return;\n      }\n\n      if (properties.animations) {\n        this.createAnimations(properties.animations);\n      }\n    },\n\n    /**\n     * Create animations from the sprite sheet.\n     * @memberof kontra.spriteSheet\n     *\n     * @param {object} animations - List of named animations to create from the Image.\n     * @param {number|string|number[]|string[]} animations.animationName.frames - A single frame or list of frames for this animation.\n     * @param {number} animations.animationName.frameSpeed=1 - Number of frames to wait before transitioning the animation to the next frame.\n     *\n     * @example\n     * var sheet = kontra.spriteSheet({image: img, frameWidth: 16, frameHeight: 16});\n     * sheet.createAnimations({\n     *   idle: {\n     *     frames: 1  // single frame animation\n     *   },\n     *   walk: {\n     *     frames: '2..6',  // ascending consecutive frame animation (frames 2-6, inclusive)\n     *     frameSpeed: 4\n     *   },\n     *   moonWalk: {\n     *     frames: '6..2',  // descending consecutive frame animation\n     *     frameSpeed: 4\n     *   },\n     *   jump: {\n     *     frames: [7, 12, 2],  // non-consecutive frame animation\n     *     frameSpeed: 3\n     *   },\n     *   attack: {\n     *     frames: ['8..10', 13, '10..8'],  // you can also mix and match, in this case frames [8,9,10,13,10,9,8]\n     *     frameSpeed: 2\n     *   }\n     * });\n     */\n    createAnimations: function createAnimations(animations) {\n      var error;\n\n      if (!animations || Object.keys(animations).length === 0) {\n        error = new ReferenceError('No animations found.');\n        kontra.logError(error, 'You must provide at least one named animation to create an Animation.');\n        return;\n      }\n\n      // create each animation by parsing the frames\n      var animation, frames, frameSpeed, sequence;\n      for (var name in animations) {\n        if (!animations.hasOwnProperty(name)) {\n          continue;\n        }\n\n        animation = animations[name];\n        frames = animation.frames;\n        frameSpeed = animation.frameSpeed;\n\n        // array that holds the order of the animation\n        sequence = [];\n\n        if (frames === undefined) {\n          error = new ReferenceError('No animation frames found.');\n          kontra.logError(error, 'Animation ' + name + ' must provide a frames property.');\n          return;\n        }\n\n        // single frame\n        if (kontra.isNumber(frames)) {\n          sequence.push(frames);\n        }\n        // consecutive frames\n        else if (kontra.isString(frames)) {\n          sequence = this._parseFrames(frames);\n        }\n        // non-consecutive frames\n        else if (kontra.isArray(frames)) {\n          for (var i = 0, frame; frame = frames[i]; i++) {\n\n            // consecutive frames\n            if (kontra.isString(frame)) {\n\n              // add new frames to the end of the array\n              sequence.push.apply(sequence, this._parseFrames(frame));\n            }\n            // single frame\n            else {\n              sequence.push(frame);\n            }\n          }\n        }\n\n        this.animations[name] = kontra.animation({\n          spriteSheet: this,\n          frames: sequence,\n          frameSpeed: frameSpeed\n        });\n      }\n    },\n\n    /**\n     * Parse a string of consecutive frames.\n     * @memberof kontra.spriteSheet\n     * @private\n     *\n     * @param {string} frames - Start and end frame.\n     *\n     * @returns {number[]} List of frames.\n     */\n    _parseFrames: function parseFrames(frames) {\n      var sequence = [];\n      var consecutiveFrames = frames.split('..').map(Number);\n\n      // determine which direction to loop\n      var direction = (consecutiveFrames[0] < consecutiveFrames[1] ? 1 : -1);\n      var i;\n\n      // ascending frame order\n      if (direction === 1) {\n        for (i = consecutiveFrames[0]; i <= consecutiveFrames[1]; i++) {\n          sequence.push(i);\n        }\n      }\n      // descending order\n      else {\n        for (i = consecutiveFrames[0]; i >= consecutiveFrames[1]; i--) {\n          sequence.push(i);\n        }\n      }\n\n      return sequence;\n    }\n  };\n\n  return kontra;\n})(kontra || {});","/**\n * localStorage can be a bit of a pain to work with since it stores everything as strings:\n * localStorage.setItem('item', 1);  //=> '1'\n * localStorage.setItem('item', false);  //=> 'false'\n * localStorage.setItem('item', [1,2,3]);  //=> '1,2,3'\n * localStorage.setItem('item', {a:'b'});  //=> '[object Object]'\n * localStorage.setItem('item', undefinedVariable);  //=> 'undefined'\n *\n * @fileoverview A simple wrapper for localStorage to make it easier to work with.\n * Based on store.js {@see https://github.com/marcuswestin/store.js}\n */\nvar kontra = (function(kontra, window, localStorage, undefined) {\n  'use strict';\n\n  // check if the browser can use localStorage\n  kontra.canUse = kontra.canUse || {};\n  kontra.canUse.localStorage = 'localStorage' in window && window.localStorage !== null;\n\n  if (!kontra.canUse.localStorage) {\n    return kontra;\n  }\n\n  /**\n   * Object for using localStorage.\n   */\n  kontra.store = {};\n\n  /**\n   * Save an item to localStorage.\n   * @memberof kontra.store\n   *\n   * @param {string} key - Name to store the item as.\n   * @param {*} value - Item to store.\n   */\n  kontra.store.set = function setStoreItem(key, value) {\n    if (value === undefined) {\n      this.remove(key);\n    }\n    else {\n      localStorage.setItem(key, JSON.stringify(value));\n    }\n  };\n\n  /**\n   * Retrieve an item from localStorage and convert it back to it's original type.\n   * @memberof kontra.store\n   *\n   * @param {string} key - Name of the item.\n   *\n   * @returns {*}\n   */\n  kontra.store.get = function getStoreItem(key) {\n    var value = localStorage.getItem(key);\n\n    try {\n      value = JSON.parse(value);\n    }\n    catch(e) {}\n\n    return value;\n  };\n\n  /**\n   * Remove an item from localStorage.\n   * @memberof kontra.store\n   *\n   * @param {string} key - Name of the item.\n   */\n  kontra.store.remove = function removeStoreItem(key) {\n    localStorage.removeItem(key);\n  };\n\n  /**\n   * Clear all keys from localStorage.\n   * @memberof kontra.store\n   */\n  kontra.store.clear = function clearStore() {\n    localStorage.clear();\n  };\n\n  return kontra;\n})(kontra || {}, window, window.localStorage);","/*jshint -W084 */\n\nvar kontra = (function(kontra, Math, undefined) {\n  'use strict';\n\n  /**\n   * A tile engine for rendering tilesets. Works well with the tile engine program Tiled.\n   * @memberof kontra\n   *\n   * @see kontra.tileEngine.prototype.set for list of parameters.\n   */\n  kontra.tileEngine = function(properties) {\n    var tileEngine = Object.create(kontra.tileEngine.prototype);\n    tileEngine.set(properties);\n\n    return tileEngine;\n  };\n\n  kontra.tileEngine.prototype = {\n    /**\n     * Set properties on the tile engine.\n     * @memberof kontra.tileEngine\n     *\n     * @param {object} properties - Properties of the tile engine.\n     * @param {number} [properties.tileWidth=32] - Width of a tile.\n     * @param {number} [properties.tileHeight=32] - Height of a tile.\n     * @param {number} properties.width - Width of the map (in tiles).\n     * @param {number} properties.height - Height of the map (in tiles).\n     * @param {number} [properties.x=0] - X position to draw.\n     * @param {number} [properties.y=0] - Y position to draw.\n     * @param {number} [properties.sx=0] - X position to clip the tileset.\n     * @param {number} [properties.sy=0] - Y position to clip the tileset.\n     * @param {Context} [properties.context=kontra.context] - Provide a context for the tile engine to draw on.\n     */\n    set: function set(properties) {\n      properties = properties || {};\n\n      var _this = this;\n\n      // size of the map (in tiles)\n      if (!properties.width || !properties.height) {\n        var error = new ReferenceError('Required parameters not found');\n        kontra.logError(error, 'You must provide width and height of the map to create a tile engine.');\n        return;\n      }\n\n      _this.width = properties.width;\n      _this.height = properties.height;\n\n      // size of the tiles. Most common tile size on opengameart.org seems to be 32x32,\n      // followed by 16x16\n      _this.tileWidth = properties.tileWidth || 32;\n      _this.tileHeight = properties.tileHeight || 32;\n\n      _this.context = properties.context || kontra.context;\n\n      _this.canvasWidth = _this.context.canvas.width;\n      _this.canvasHeight = _this.context.canvas.height;\n\n      // create an off-screen canvas for pre-rendering the map\n      // @see http://jsperf.com/render-vs-prerender\n      _this._offscreenCanvas = document.createElement('canvas');\n      _this._offscreenContext = _this._offscreenCanvas.getContext('2d');\n\n      // make the off-screen canvas the full size of the map\n      _this._offscreenCanvas.width = _this.mapWidth = _this.width * _this.tileWidth;\n      _this._offscreenCanvas.height = _this.mapHeight = _this.height * _this.tileHeight;\n\n      // when clipping an image, sx and sy must within the image region, otherwise\n      // Firefox and Safari won't draw it.\n      // @see http://stackoverflow.com/questions/19338032/canvas-indexsizeerror-index-or-size-is-negative-or-greater-than-the-allowed-a\n      _this.sxMax = _this.mapWidth - _this.canvasWidth;\n      _this.syMax = _this.mapHeight - _this.canvasHeight;\n\n      _this.layers = {};\n\n      // draw order of layers (by name)\n      _this._layerOrder = [];\n\n      // each tileset will hold the first and the last grid as well as the image for the tileset\n      _this.tilesets = [];\n\n      _this.x = properties.x || 0;\n      _this.y = properties.y || 0;\n      _this.sx = properties.sx || 0;\n      _this.sy = properties.sy || 0;\n    },\n\n    /**\n     * Add an tileset for the tile engine to use.\n     * @memberof kontra.tileEngine\n     *\n     * @param {object} properties - Properties of the image to add.\n     * @param {string|Image|Canvas} properties.image - Path to the image or Image object.\n     * @param {number} properties.firstGrid - The first tile grid to start the image.\n     */\n    addTileset: function addTileset(properties) {\n      properties = properties || {};\n\n      if (kontra.isImage(properties.image) || kontra.isCanvas(properties.image)) {\n        var image = properties.image;\n        var firstGrid = properties.firstGrid;\n        var numTiles = (image.width / this.tileWidth | 0) * (image.height / this.tileHeight | 0);\n\n        if (!firstGrid) {\n          // only calculate the first grid if the tile map has a tileset already\n          if (this.tilesets.length > 0) {\n            var lastTileset = this.tilesets[this.tilesets.length - 1];\n            var tiles = (lastTileset.image.width / this.tileWidth | 0) *\n                        (lastTileset.image.height / this.tileHeight | 0);\n\n            firstGrid = lastTileset.firstGrid + tiles - 1;\n          }\n          // otherwise this is the first tile added to the tile map\n          else {\n            firstGrid = 1;\n          }\n        }\n\n        this.tilesets.push({\n          firstGrid: firstGrid,\n          lastGrid: firstGrid + numTiles - 1,\n          image: image\n        });\n\n        // sort the tile map so we can perform a binary search when drawing\n        this.tilesets.sort(function(a, b) {\n          return a.firstGrid - b.firstGrid;\n        });\n      }\n      else {\n        var error = new SyntaxError('Invalid image.');\n        kontra.logError(error, 'You must provide an Image for the tile engine.');\n        return;\n      }\n    },\n\n    /**\n     * Add a layer to the tile engine.\n     * @memberof kontra.tileEngine\n     *\n     * @param {object} properties - Properties of the layer to add.\n     * @param {string} properties.name - Name of the layer.\n     * @param {number[]} properties.data - Tile layer data.\n     * @param {boolean} [properties.render=true] - If the layer should be drawn.\n     * @param {number} properties.zIndex - Draw order for tile layer. Highest number is drawn last (i.e. on top of all other layers).\n     */\n    addLayer: function addLayer(properties) {\n      properties = properties || {};\n      properties.render = (properties.render === undefined ? true : properties.render);\n\n      var _this = this;\n      var data;\n\n      // flatten a 2D array into a single array\n      if (kontra.isArray(properties.data[0])) {\n        data = [];\n\n        for (var r = 0, row; row = properties.data[r]; r++) {\n          for (var c = 0, length = row.length; c < length; c++) {\n            data.push(row[c]);\n          }\n        }\n      }\n      else {\n        data = properties.data;\n      }\n\n      this.layers[properties.name] = data;\n      this.layers[properties.name].zIndex = properties.zIndex || 0;\n      this.layers[properties.name].render = properties.render;\n\n      // only add the layer to the layer order if it should be drawn\n      if (properties.render) {\n        this._layerOrder.push(properties.name);\n\n        this._layerOrder.sort(function(a, b) {\n          return _this.layers[a].zIndex - _this.layers[b].zIndex;\n        });\n\n        this._preRenderImage();\n      }\n    },\n\n    /**\n     * Simple bounding box collision test for layer tiles.\n     * @memberof kontra.tileEngine\n     *\n     * @param {string} name - Name of the layer.\n     * @param {object} object - Object to check collision against.\n     * @param {number} object.x - X coordinate of the object.\n     * @param {number} object.y - Y coordinate of the object.\n     * @param {number} object.width - Width of the object.\n     * @param {number} object.height - Height of the object.\n     *\n     * @returns {boolean} True if the object collides with a tile, false otherwise.\n     */\n    layerCollidesWith: function layerCollidesWith(name, object) {\n      // handle non-kontra.sprite objects as well as kontra.sprite objects\n      var x = (object.x !== undefined ? object.x : object.position.x);\n      var y = (object.y !== undefined ? object.y : object.position.y);\n\n      // calculate all tiles that the object can collide with\n      var row = this._getRow(y);\n      var col = this._getCol(x);\n\n      var endRow = this._getRow(y + object.height);\n      var endCol = this._getCol(x + object.width);\n\n      // check all tiles\n      var index;\n      for (var r = row; r <= endRow; r++) {\n        for (var c = col; c <= endCol; c++) {\n          index = c + r * this.width;\n\n          if (this.layers[name][index]) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Get the tile from the specified layer at x, y.\n     * @memberof kontra.tileEngine\n     *\n     * @param {string} name - Name of the layer.\n     * @param {number} x - X coordinate of the tile.\n     * @param {number} y - Y coordinate of the tile.\n     *\n     * @returns {number}\n     */\n    tileAtLayer: function tileAtLayer(name, x, y) {\n      var row = this._getRow(y);\n      var col = this._getCol(x);\n      var index = col + row * this.width;\n\n      return this.layers[name][index];\n    },\n\n    /**\n     * Render the pre-rendered canvas.\n     * @memberof kontra.tileEngine\n     */\n    render: function render() {\n      var _this = this;\n\n      // ensure sx and sy are within the image region\n      _this.sx = Math.min( Math.max(_this.sx, 0), _this.sxMax );\n      _this.sy = Math.min( Math.max(_this.sy, 0), _this.syMax );\n\n      _this.context.drawImage(\n        _this._offscreenCanvas,\n        _this.sx, _this.sy, _this.canvasWidth, _this.canvasHeight,\n        _this.x, _this.y, _this.canvasWidth, _this.canvasHeight\n      );\n    },\n\n    /**\n     * Render a specific layer.\n     * @memberof kontra.tileEngine\n     *\n     * @param {string} name - Name of the layer to render.\n     */\n    renderLayer: function renderLayer(name) {\n      var _this = this;\n\n      var layer = _this.layers[name];\n\n      // calculate the starting tile\n      var row = _this._getRow();\n      var col = _this._getCol();\n      var index = col + row * _this.width;\n\n      // calculate where to start drawing the tile relative to the drawing canvas\n      var startX = col * _this.tileWidth - _this.sx;\n      var startY = row * _this.tileHeight - _this.sy;\n\n      // calculate how many tiles the drawing canvas can hold\n      var viewWidth = Math.ceil(_this.canvasWidth / _this.tileWidth) + 1;\n      var viewHeight = Math.ceil(_this.canvasHeight / _this.tileHeight) + 1;\n      var numTiles = viewWidth * viewHeight;\n\n      var count = 0;\n      var x, y, tile, tileset, image, tileOffset, width, sx, sy;\n\n      // draw just enough of the layer to fit inside the drawing canvas\n      while (count < numTiles) {\n        tile = layer[index];\n\n        if (tile) {\n          tileset = _this._getTileset(tile);\n          image = tileset.image;\n\n          x = startX + (count % viewWidth) * _this.tileWidth;\n          y = startY + (count / viewWidth | 0) * _this.tileHeight;\n\n          tileOffset = tile - tileset.firstGrid;\n          width = image.width / _this.tileWidth;\n\n          sx = (tileOffset % width) * _this.tileWidth;\n          sy = (tileOffset / width | 0) * _this.tileHeight;\n\n          _this.context.drawImage(\n            image,\n            sx, sy, _this.tileWidth, _this.tileHeight,\n            x, y, _this.tileWidth, _this.tileHeight\n          );\n        }\n\n        if (++count % viewWidth === 0) {\n          index = col + (++row * _this.width);\n        }\n        else {\n          index++;\n        }\n      }\n    },\n\n    /**\n     * Get the row from the y coordinate.\n     * @memberof kontra.tileEngine\n     * @private\n     *\n     * @param {number} y - Y coordinate.\n     *\n     * @return {number}\n     */\n    _getRow: function getRow(y) {\n      y = y || 0;\n\n      return (this.sy + y) / this.tileHeight | 0;\n    },\n\n    /**\n     * Get the col from the x coordinate.\n     * @memberof kontra.tileEngine\n     * @private\n     *\n     * @param {number} x - X coordinate.\n     *\n     * @return {number}\n     */\n    _getCol: function getCol(x) {\n      x = x || 0;\n\n      return (this.sx + x) / this.tileWidth | 0;\n    },\n\n    /**\n     * Modified binary search that will return the tileset associated with the tile\n     * @memberOf kontra.tileEngine\n     * @private\n     *\n     * @param {number} tile - Tile grid.\n     *\n     * @return {object}\n     */\n    _getTileset: function getTileset(tile) {\n      var min = 0;\n      var max = this.tilesets.length - 1;\n      var index;\n      var currTile;\n\n      while (min <= max) {\n        index = (min + max) / 2 | 0;\n        currTile = this.tilesets[index];\n\n        if (tile >= currTile.firstGrid && tile <= currTile.lastGrid) {\n          return currTile;\n        }\n        else if (currTile < tile) {\n          min = index + 1;\n        }\n        else {\n          max = index - 1;\n        }\n      }\n    },\n\n    /**\n     * Pre-render the tiles to make drawing fast.\n     */\n    _preRenderImage: function preRenderImage() {\n      var _this = this;\n      var tile, tileset, image, x, y, sx, sy, tileOffset, width;\n\n      // draw each layer in order\n      for (var i = 0, layer; layer = _this.layers[_this._layerOrder[i]]; i++) {\n        for (var j = 0, len = layer.length; j < len; j++) {\n          tile = layer[j];\n\n          // skip empty tiles (0)\n          if (!tile) {\n            continue;\n          }\n\n          tileset = _this._getTileset(tile);\n          image = tileset.image;\n\n          x = (j % _this.width) * _this.tileWidth;\n          y = (j / _this.width | 0) * _this.tileHeight;\n\n          tileOffset = tile - tileset.firstGrid;\n          width = image.width / _this.tileWidth;\n\n          sx = (tileOffset % width) * _this.tileWidth;\n          sy = (tileOffset / width | 0) * _this.tileHeight;\n\n          _this._offscreenContext.drawImage(\n            image,\n            sx, sy, _this.tileWidth, _this.tileHeight,\n            x, y, _this.tileWidth, _this.tileHeight\n          );\n        }\n      }\n    }\n  };\n\n  return kontra;\n})(kontra || {}, Math);"],"sourceRoot":"/source/"}